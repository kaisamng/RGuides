# Working with Dataframes

## Destructive Operations with Dataframes
```{r, echo=FALSE}
friends <- data.frame(names = c("Abram", "Bryant", "Colleen", "David", "Esther", "Jeremiah"),
           ages = c(34, 35, 32, 29, 30, 30),
           DC_Resident = c(TRUE, FALSE, FALSE, TRUE, FALSE, TRUE),
           fav_number = c(1, 2.17, 26, 7, 10, 9),
           stringsAsFactors = FALSE)
```
Destructive operations are any operation where you override the original data. This is not necessairly a bad thing-- sometimes, we don't have a need for the original data, but want to manipulate it in some way. However, it means that if you made a mistake, the only way to revert the mistake is to completely reload the data from its original source, and repeat all your operations again. As in \@ref(vector-operations), you can alter your dataframe by using the storage operator `<-` to overwrite data.

### Replacing one element 

Let's say that I accidentally typed 'Abram' as my friend's name, and I want to replace it with 'Abe'

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
friends$names[1]<- "Abe"
friends
```

### Replacing columns with a mathematical formula

I want to see what everybody's age is in 50 years.

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
friends$ages<- friends$ages+50
friends
```

### Replacing entire columns with another vector

I want to add their last names.

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
friends$names <- c("Abram A", "Bryant B", "Colleen C", "David D", "Esther E", "Jeremiah J")
friends
```

Note in the last example, I had to type the entire vector I planned to override. That's because these are characters, and if you use the `+` operator, R will return an error saying that you can't add "a" with "b". We will discuss a better way to do this, below.

### Dropping Rows

Or I added the first person by mistake to my Friends list, so I have to drop the first row that represents "Abram A":

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
friends<- friends[-1, ]

friends
```







::: rmdtip
Let's practice importing data, from \@ref(dataframe). Download the [periodic table](https://downgit.github.io/#/home?url=https://github.com/kaisamng/RGuides/blob/main/resources/data/periodic-table-data.csv){target="_blank"} data now, and import it into R as `periodic_table`.

-   Remember to move this into your working directory: `getwd()`

-   Since this is a CSV file, use the **From Text (readr)** function.

-   Change the name of the data set to **periodic_table** before you import it. Remember that's on the bottom left.


:::

The first 10 rows of `periodic_table` are reproduced below.

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(readr)
periodic_table <- read_csv("resources/data/periodic-table-data.csv")
```

```{r, echo=FALSE, fig.cap="The Periodic Table"}
knitr::kable(periodic_table[1:10,], caption="The Periodic Table", booktabs=TRUE) %>%
  scroll_box(height="500px") %>%
  kable_styling(position= "center", font_size = 10)
```

So we have a big data frame of information about the periodic table, but what if we wanted to extract smaller pieces of the data frame?

## Filtering Data

### Selecting a column using `$`

By default, R will organize character strings in alphabetical order. To see this, we'll introduce two new features: the `table` function and the `$` operator.

Let's say I'm interested in elements in a gas, liquid, and solid state at room temperature. Looking at the `periodic_table` columns, I see that the column that gives me that information is `state_at_stp`.

```{r, attr.output='style="max-height: 100px; font-size:10px;"'}
periodic_table$state_at_stp

```

As you can see, to access specific variables inside a data frame, we can do so by entering the name of the data frame followed by `$` and the name of the variable. (Note that spaces in variable names will not work. You'll likely learn that the hard way, as I have.)

### Using `[ , ]` for a dataframe

Recall in \@ref(vector-selection) section that we could use the `[ ]` operator, to select elements from a single vector. We can extend these operations into a dataframe.

A single vector can be thought of as a dataframe with one row and $n$ columns, which is why you just needed a single number to select an element. Now, since there are multiple rows and columns, you need a comma to differentiate the row and column index.

The `[ ]` operator allows you to select elements within a vector or a dataframe **based on its row and column position.** It starts by locating the row position, and then the column position.

#### Selecting a single element using `[ , ]`

Let's say I wanted to select the `name` for `Sodium`, that is in row 11, column 3.

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
periodic_table[11, 3]

periodic_table$name[11]
```

Notice that both commands above give me the desired value-- Sodium-- but the formats are different. + In the first command, R gives me back a table with 1 row and 1 column. This isn't a coincidence, because you pulled directly from the table itself. It's the difference between copying a "cell" in Excel versus double-clicking on the cell, and then copying the text inside. Here, you directly pulled from the table, so R returns back a value within a table. + The second gives me a single character vector. This makes sense-- the `$` operator selects a single vector `name` from the table, and then selects the 11th element. Generally, this is the way you want to select a single table.

Recall the use of `[ ]` when a vector was printed, to help us better understand where we were in printing a large vector. We can use this same tool to select the tenth to the twentieth elements of the `periodic_table$name` variable:

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
periodic_table$name[10:20]
```

#### Selecting rows and columns using `[ , ]`

You have now seen how to select specific elements of a vector or a variable, but what if we want a subset of the values in the full data frame across both rows (observations) and columns (variables).?

We can use `[ , ]` where the spot before the comma corresponds to rows and the spot after the comma corresponds to columns. Let's select rows 40 to 50 and columns 1, 2, and 4 from `periodic_table`:

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
periodic_table[41:50, c(1, 2, 4)]
```

#### "Let's eat Grandma!" vs. "Let's eat, Grandma!" {.unnumbered}

::: rmdwarning
**The comma is very important.** Let's look at some examples:
:::

```{r,attr.output='style="max-height: 150px; font-size:10px;"'}
#Returns all of column 2:
periodic_table[2]

#Returns all of row 2:
periodic_table[2, ]

#Returns all of column 2:
periodic_table[ ,2]

#Returns a single element in Row 2, Column 2:
periodic_table[2,2]
```

## Using `%in%`, `==`, and Logical Vectors

Recall in \@ref(vector-logical-selection) that we could use a logical vector, and the `%in%` operator, to select elements from a single vector. We can extend these operations into a dataframe.

At its most basic level, you can use the `==` operator to test whether one element **exactly** matches another. For example, `"gas"=="gas"` returns TRUE, but `"gas"=="Gas"` will return false.

Let's say that I want to find any elements that are naturally gasses.

```{r, attr.output='style="max-height: 200px; font-size:10px;"'}
periodic_table[periodic_table$state_at_stp == "Liquid", ]
```

You'll notice that this returns back a massive table of `NAs`, rather than just the two elements that exist in liquid state! Why?

Let's examine the command `periodic_table$state_at_stp=="Liquid"` more carefully.

```{r, attr.output='style="max-height: 100px; font-size:10px;"'}
periodic_table$state_at_stp=="Liquid"
```

-   Every time the element's state is not `Liquid`, R returns False, instead of ignoring the row, which means you get a logical vector of all 118 elements.
-   This gets passed onto the subset function, which, rather than ignore any row that says FALSE, returns each row as entirely NAs.

Although this technically does the job you want, it is not a very elegant solution, which is why the `%in%` operator is better.

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
periodic_table[periodic_table$state_at_stp %in% "Liquid", ]
```

Much better. Notice that, with this call, we didn't specify any columns for R to filter out, so it left those blank.

Now we can think about how to subset an entire data frame using the same sort of creation of two logical vectors (one for rows and one for columns):

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
periodic_table[ (periodic_table$name %in% c("Hydrogen", "Oxygen") ),
        c("atomic_weight", "state_at_stp")]
```

The extra parentheses around `periodic_table$name %in% c("Hydrogen", "Oxygen")` are a good habit to get into as they ensure everything before the comma is used to select specific rows matching that condition. For the columns, we can specify a vector of the column names to focus on only those variables. The resulting table here gives the `atomic_weight` and `state_at_stp` for `"Hydrogen"` and then for `"Oxygen"`.

There are many more complicated ways to subset a data frame and one can use the `subset` function built into R, but in my experience, whenever you want to do anything more complicated than what we have done here, it is easier to use the `filter` and `select` functions in the `dplyr` package.

### Comparison Operators
These operators are self explanatory. The `<` and `>` can be used to select rows based on a **numeric** condition.

`!=` is the **not equals** operator. This operator allows for both numeric and character types. 

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
# Prints any row whose atomic number is less than 10.
periodic_table[periodic_table$atomic_number<10,]

#Prints any row whose state at standard room temperature is not Solid.
periodic_table[periodic_table$state_at_stp != "Solid",]
```

### Combining logical operators with "or", "and" conditions
Finally, the `&` operator means **and**, and the `|` operator means **or**. You can fund `|` by pressing the shirt key and kitting the "reverse slash" key above the `enter` key on your keyboard. 

It allows you to combine multiple logical statements together, which may be useful if you have multiple criteria to work on.

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
#Prints any element which is Non-metal AND whose  atomic number is less than 15
periodic_table[periodic_table$description != "Non-metal" & periodic_table$atomic_number <15,]

#Prints any element which is Non-metal OR whose atomic number is less than 15
periodic_table[periodic_table$description != "Non-metal" | periodic_table$atomic_number <15,]
```

## Non-Destructive Operations with Dataframes

Whew! Now that we've learned how to filter properly, and select columns, we can talk about non-destructive operations. 

### Creating New Columns using a Vector
Let's return to our original `friends` dataframe. Rather than replacing original data, we might prefer to add columns to reach the same purpose. Let's return to the example where I want to include my friend's last names. A smarter thing to do would be to **add a column.**
```{r, echo=FALSE}
friends <- data.frame(names = c("Abram", "Bryant", "Colleen", "David", "Esther", "Jeremiah"),
           ages = c(34, 35, 32, 29, 30, 30),
           DC_Resident = c(TRUE, FALSE, FALSE, TRUE, FALSE, TRUE),
           fav_number = c(1, 2.17, 26, 7, 10, 9),
           stringsAsFactors = FALSE)
```

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
last_names<- c("A", "B", "C", "D", "E", "J") 
#Method 1: Use $

friends$last_names<- last_names

#Method 2: Use []. Notice that the column name is in quotes, because this is a name. If you don't have the quotes, R will literally use the vector to create a new column for each element in the vector last_names. 

friends[ ,'last_names']<- last_names
friends
```

### Merging two columns together into a new column

The last names are great, but we can improve even on this by `paste()`ing the `names` column and the `last_names` column. 

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
friends$full_names<- paste(friends$names, friends$last_names)
friends

```

The paste function takes separate elements and combines them into one. Notice that this is different from the `c()` function, which keeps elements separate into a single list. 

There are many other ways to also combine columns together, like the `stringr` package or the `tidyr` package, which you can learn here, but are outside the scope of the book. 

### Merging two numerical columns into a new column

Combining two columns doesn't make sense for numerical vectors-- after all, if we want to combine 4 and 1, we don't want `4, 1`, we want 5 as our answer. Let's say I want to add my friend's ages to their favorite number (no reason why). Since we can add, subtract, and any other mathematical operation to two vectors as long as they have the same number of elements, this is easy to do. 

```{r, attr.output='style="max-height: 150px; font-size:10px;"'}
friends$age_and_fav_number<- friends$ages + friends$fav_number
friends

```

# Vectors and Dataframe Exercises {-}

<iframe style="margin:0 auto; min-width: 100%;" id="ch2-4-exercises" class="interactive" src="https://kaisamng.shinyapps.io/Chapters_2_4_Exercises/" scrolling="no" frameborder="no">

</iframe>


<script>
  iFrameResize({}, ".interactive");
</script>

